% Copyright (C) 2008, 2009, 2010, 2011, 2012, 2014 Bert Burgemeister
%
% Permission is granted to copy, distribute and/or modify this
% document under the terms of the GNU Free Documentation License,
% Version 1.2; with no Invariant Sections, no Front-Cover Texts and
% no Back-Cover Texts. For details see file COPYING.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CLOS} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{类} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{LIST}{1cm}

  \IT{(\FU*{SLOT-EXISTS-P} \VAR{foo} \VAR{bar})\qquad\qquad}
  {
    当 \VAR{foo} 含有槽 \VAR{bar} 时为 \retval{\T}。
  }

  \IT{(\FU*{SLOT-BOUNDP} \VAR{instance} \VAR{slot})}
  {
    当 \VAR{instance} 的 \VAR{slot} 已绑定时为 \retval{\T}。
  }

  \IT{(\MC*{DEFCLASS} \VAR{foo} 
    (\OPn{\VAR{superclass}}\DF{\kwd{standard-object}})
    (\xorGOO{%
      \VAR{slot}\\
      (\VAR{slot }
      \orGOO{%
        \Goos{\kwd{:reader} \VAR{reader}}\\
        \Goos{\kwd{:writer} \xorGOO{%
            \VAR{writer}\\
            ({\kwd{setf}\VAR{ writer}})}{\}}} \\
        \Goos{\kwd{:accessor} \VAR{accessor}} \\
        \kwd{:allocation } \xorGOO{%
          \kwd{:instance}\\
          \kwd{:class}}{\}}\DF{\kwd{:instance}}\\
        \Goos{\kwd{:initarg} \kwd{:}\VAR{initarg-name}} \\
        \kwd{:initform} \VAR{ form}\\
        \kwd{:type} \VAR{ type}\\
        \kwd{:documentation}
        \VAR{ slot-doc}}{\}})}{\}^{\!\!\!*}})
    \orGOO{%
      (\kwd{:default-initargs } \Goos{\VAR{name}\VAR{ value}})\\
      (\kwd{:documentation} \VAR{ class-doc})\\
      (\kwd{:metaclass} \VAR{ name}\DF{\kwd{standard-class}})}{\}})}
  {
    定义或修改 \VAR{superclass}es 的子类
    \retval{类 \VAR{foo}}。将用 \GFU{make-instances-obsolete}
    修改已存在的实例。在 \VAR{foo} 的新实例 \VAR{i}
    中，\VAR{slot} 的值默认为 \VAR{form}，或用
    \kwd{:}\VAR{initarg-name} 设置。此值可通过 (\VAR{reader}
    \VAR{i}) 或 (\VAR{accessor} \VAR{i}) 读取，(\VAR{writer}
    \VAR{value} \VAR{i}) 或 (\kwd{setf} (\VAR{accessor}
    \VAR{i}) \VAR{value}) 写入。带 \kwd{:allocation :class}
    的 \VAR{slot}s 在 \VAR{foo} 的所有实例间共享。
  }

  \IT{(\FU*{FIND-CLASS} \VAR{symbol} \OP{\VAR{errorp}\DF{\T}
      \Op{\VAR{environment}}})}
  {
    返回名为 \VAR{symbol} 的 \retval{类}。可 \kwd{setf}。
  }

  \IT{(\GFU*{MAKE-INSTANCE} \VAR{class} \Goos{\kwd{:}\VAR{initarg}
      \VAR{value}} \OPn{\VAR{other-keyarg}})}
  {
    生成新的 \retval{\VAR{class} 实例}。
  }

  \IT{(\GFU*{REINITIALIZE-INSTANCE} \VAR{instance} \Goos{\kwd{:}\VAR{initarg}
      \VAR{value}} \OPn{\VAR{other-keyarg}})}
  {
    用 \GFU{shared-initialize} 修改 \retval{\VAR{instance}}
    的本地槽 \VAR{initarg}s。
  }

  \IT{(\FU*{SLOT-VALUE} \VAR{foo} \VAR{slot})}
  {
    返回 \retval{
      \VAR{foo} 中 \VAR{slot} 的值}。可 \kwd{SETF}。
  }

  \IT{(\FU*{SLOT-MAKUNBOUND} \VAR{instance} \VAR{slot})}
  {
    将 \retval{\VAR{instance}} 中的 \VAR{slot} 解绑。
  }

  \IT{(\xorGOO{%
      \MC*{WITH-SLOTS } (\Goos{\NEV{\VAR{slot}}\XOR(\NEV{\VAR{var}} \NEV{\VAR{slot}})})\\
      \MC*{WITH-ACCESSORS } (\OPn{(\NEV{\VAR{var}}\text{ } \NEV{\VAR{accessor}})})}{\}}
    \VAR{instance}  \OPn{(\kwd{declare} \OPn{\NEV{\VAR{decl}}})}
    \PROGN{\VAR{form}})}
  {
    在 \VAR{instance} 的槽作为可 \kwd{setf} 的
    \VAR{slot}s 或 \VAR{var}s / \VAR{instance}
    的 \VAR{accessor}s 作为可 \kwd{setf} 的 \VAR{var}s
    的词法环境中求值并返回 \retval{\VAR{form}s 的所有值}。
  }

  \IT{\arrGOO{(\GFU*{CLASS-NAME } \VAR{class})\\
      ((\kwd{setf } \GFU*{CLASS-NAME}) \VAR{ new-name } \VAR{class})}{.}}
  {
    获取/设置 \retval{\VAR{class} 的名称}。
  }

  \IT{(\FU*{CLASS-OF} \VAR{foo})}
  {
    \VAR{foo} 的直接基 \retval{类}。
  }

  \IT{(\GFU*{CHANGE-CLASS} \DES{\VAR{instance}} \VAR{new-class}
    \Goos{\kwd{:}\VAR{initarg} \VAR{value}} \OPn{\VAR{other-keyarg}})} 
  {
    将 \retval{\VAR{instance}} 的类更改为
    \VAR{new-class}。保留 \VAR{instance}
    原始类和新类相同槽的状态。用相应的
    \VAR{initarg}s 或
    \kwd{:initform} 的值
    给出的值初始化新添加的槽。
  }

  \IT{(\GFU*{MAKE-INSTANCES-OBSOLETE} \VAR{class})}
  {
    使用 \GFU{update-instance-for-redefined-class}
    更新 \VAR{class} 的所有实例。
  }

  \IT{(\xorGOO{%
      \GFU*{INITIALIZE-INSTANCE } \VAR{instance}\\
      \GFU*{UPDATE-INSTANCE-FOR-DIFFERENT-CLASS} 
      \VAR{ previous }\VAR{current}}{\}}
    \Goos{\kwd{:}\VAR{initarg}
      \VAR{value}} \OPn{\VAR{other-keyarg}})}
  {
    类似 \GFU{make-instance}/\GFU{change-class}，但用
    \GFU{shared-initialize} 设置槽。
  }

  \IT{(\GFU*{UPDATE-INSTANCE-FOR-REDEFINED-CLASS}
    \VAR{new-instance}
    \VAR{added-slots}
    \VAR{discarded-slots}
    \VAR{discarded-slots-property-list}
    \Goos{%
      \kwd{:}\VAR{initarg}
      \VAR{value}}
    \OPn{\VAR{other-keyarg}})}
  {
    类似 \GFU{make-instances-obsolete}，但使用
    \GFU{shared-initialize} 设置槽 \VAR{initarg}
    为对应的 \VAR{value}s，设置剩余的
    \VAR{added-slots} 为 \kwd{:initform}
    形式的值。不应由用户调用。
  }

  \IT{(\GFU*{ALLOCATE-INSTANCE} \VAR{class} \Goos{\kwd{:}\VAR{initarg}
      \VAR{value}} \OPn{\VAR{other-keyarg}})}
  {
    返回 \VAR{class} 的未初始化 \retval{实例}。由
    \GFU{make-instance} 调用。
  }

  \IT{(\GFU*{SHARED-INITIALIZE} \VAR{instance} 
    \xorGOO{%
      \VAR{initform-slots}\\
      \T}{\}}
     \Goos{\kwd{:}%
       \VAR{initarg-slot}
       \VAR{value}} 
     \OPn{\VAR{other-keyarg}})}
  {
    Fill the \VAR{initarg-slot}s of \VAR{instance} with the
    corresponding \VAR{value}s, and fill those \VAR{initform-slots}
    that are not \VAR{initarg-slot}s with the values of their
    \kwd{:initform} forms.
  }

  \IT{\arrGOO{%
      (\GFU*{SLOT-MISSING } \VAR{class } \VAR{instance } \VAR{slot }
      \xorGOO{%
        \kwd{setf}\\
        \kwd{slot-boundp}\\
        \kwd{slot-makunbound}\\
        \kwd{slot-value}}{\}}
      \Op{\VAR{value}})\\
      (\GFU*{SLOT-UNBOUND } \VAR{class } \VAR{instance } \VAR{slot})}{.}}
  {
    Called on attempted access to non-existing or unbound
    \VAR{slot}. Default methods signal \kwd{error}/\kwd{unbound-slot},
    respectively.  Not to be called by user.
}

\end{LIST}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{广义函数} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{LIST}{1cm}
  \IT{(\FU*{NEXT-METHOD-P})}
  {
    当方法存在下一方法时为 \retval{\T}。
  }

  \IT{(\MC*{DEFGENERIC}
    \xorGOO{\VAR{foo}\\ (\kwd{setf} \VAR{ foo})}{\}} 
    (\OPn{\VAR{required-var}}
    \OP{\kwd{\&optional} \xorGOO{%
        \VAR{var}\\
        (\VAR{var})}{\}^{\!\!*}}}
    \OP{\kwd{\&rest} \VAR{var}}
    \OP{\kwd{\&key} \xorGOO{%
        \VAR{var}\\
        (\VAR{var}\XOR(\kwd{:}\VAR{key }
        \VAR{var}))}{\}^{\!\!*}} \Op{\kwd{\&allow-other-keys}}})
    \orGOO{%
      (\kwd{:argument-precedence-order}\RP{\VAR{ required-var}})\\
      (\kwd{declare }\RP{(\kwd{optimize}\VAR{ method-selection-optimization})})\\
      (\kwd{:documentation } \NEV{\VAR{string}})\\
      (\kwd{:generic-function-class} 
      \VAR{ gf-class}\DF{\kwd{standard-generic-function}})\\
      (\kwd{:method-class} \VAR{ method-class}\DF{\kwd{standard-method}})\\
      (\kwd{:method-combination} 
      \VAR{ c-type}\DF{\kwd{standard}} \OPn{\VAR{ c-arg}})\\
      \OPn{(\kwd{:method} \VAR{ defmethod-args})}}{\}})}
  {
    Define or modify \retval{generic function} \VAR{foo}.  Remove any
    methods previously defined by defgeneric.  \VAR{gf-class} and the lambda
    paramters \OPn{\VAR{required-var}} and \OPn{\VAR{var}} must be
    compatible with existing methods.  \VAR{defmethod-args}
    resemble those of \MC{defmethod}.  For \VAR{c-type} see section
    \ref{section:方法组合类型}。
  }

  \IT{(\FU*{ENSURE-GENERIC-FUNCTION}
    \xorGOO{\VAR{foo}\\ (\kwd{setf} \VAR{ foo})}{\}}
    \orGOO{%
      \kwd{:argument-precedence-order}\RP{\VAR{ required-var}}\\
      \kwd{:declare }(\kwd{optimize}\VAR{ method-selection-optimization})\\
      \kwd{:documentation} \VAR{ string}\\
      \kwd{:generic-function-class} \VAR{ gf-class}\\
      \kwd{:method-class} \VAR{ method-class}\\
      \kwd{:method-combination} \VAR{ c-type} \OPn{\VAR{ c-arg}}\\
      \kwd{:lambda-list} \VAR{ lambda-list}\\
      \kwd{:environment} \VAR{ environment}}{\}})}
  {
    Define or modify \retval{generic function}
    \VAR{foo}. \VAR{gf-class} and \VAR{lambda-list}
    must be compatible with a pre-existing generic function or with
    existing methods, respectively. Changes to \VAR{method-class} do
    not propagate to existing methods. For \VAR{c-type} see section
    \ref{section:方法组合类型}。
  }

  \IT{(\MC*{DEFMETHOD} 
    \xorGOO{\VAR{foo}\\ 
      (\kwd{setf} \VAR{ foo})}{\}} 
    \Op{\xorGOO{\kwd{:before}\\
        \kwd{:after}\\
        \kwd{:around}\\
        \OPn{\VAR{qualifier}}}{\}}\DF{primary method}}
    (\xorGOO{\VAR{var}\\
      (\VAR{spec-var } \xorGOO{\VAR{class}\\
        (\kwd{eql} \VAR{ bar})}{\}})}{\}^{\!\!*}}
    \OP{\kwd{\&optional} \xorGOO{\VAR{var}\\
        (\VAR{var } \OP{\VAR{init }
          \Op{\VAR{supplied-p}}})}{\}^{\!\!*}}}
    \Op{\kwd{\&rest} \VAR{var}}
    \OP{\kwd{\&key} \xorGOO{\VAR{var}\\
        (\xorGOO{\VAR{var}\\
          (\kwd{:}\VAR{key }
          \VAR{var})}{\}}
        \OP{\VAR{init }\Op{\VAR{supplied-p}}})}{\}^{\!\!*}}
      \Op{\kwd{\&allow-other-keys}}}
    \OP{\kwd{\&aux }\xorGOO{\VAR{var}\\
        (\VAR{var } \Op{\VAR{init}})}{\}^{\!\!*}}})
    \orGOO{\OPn{(\kwd{declare } \OPn{\NEV{\VAR{decl}}})}\\
      \NEV{\VAR{doc}}}{\}}
    \PROGN{\VAR{form}})}
  {
    Define \retval{new method} for generic function
    \VAR{foo}. \VAR{spec-var}s specialize to either being of \VAR{class}
    or being \kwd{eql} \VAR{bar}, respectively. On invocation, \VAR{var}s and
    \VAR{spec-var}s of the \retval{new method}
    act like parameters of a function with body
    \OPn{\VAR{form}}. \VAR{form}s are enclosed in an implicit \SO{block}
    \VAR{foo}. Applicable \VAR{qualifier}s depend on the
    \kwd{method-combination} type; see
    section \ref{section:方法组合类型}。
  }

  \IT{(\xorGOO{\GFU*{ADD-METHOD}\\
      \GFU*{REMOVE-METHOD}}{\}} \VAR{generic-function} \VAR{method})}
  {
    Add (if necessary) or remove (if any) \VAR{method} to/from
    \retval{\VAR{generic-function}}. 
  }

  \IT{(\GFU*{FIND-METHOD} \VAR{generic-function} \VAR{qualifiers}
    \VAR{specializers} \Op{\VAR{error}\DF{\T}})}
  {
    返回合适的 \retval{方法}，或产生 \kwd{error}。
  }

  \IT{(\GFU*{COMPUTE-APPLICABLE-METHODS} \VAR{generic-function}
    \VAR{args})}
  {
    \VAR{args} 合适的 \retval{方法列表}，最具体的在前。
  }

  \IT{(\FU*{CALL-NEXT-METHOD} \OPn{\VAR{arg}}\DF{current args})}
  {
    From within a method, call next method with \VAR{arg}s; return
    \retval{its values}.
  }

  \IT{(\GFU*{NO-APPLICABLE-METHOD} \VAR{generic-function}
    \OPn{\VAR{arg}})}
  {
    Called on invocation of \VAR{generic-function} on \VAR{arg}s if
    there is no applicable method.  Default method signals
    \kwd{error}.  Not to be called by user.
  }

  \IT{(\xorGOO{%
      \FU*{INVALID-METHOD-ERROR} \VAR{ method}\\
      \FU*{METHOD-COMBINATION-ERROR}}{\}}
    \VAR{control} \OPn{\VAR{arg}})}
  {
    Signal \kwd{error} on applicable method with invalid qualifiers, or
    on method combination. For \VAR{control} and \VAR{arg}s see
    \kwd{format}, page \pageref{section:Format}.
  }

  \IT{(\GFU*{NO-NEXT-METHOD} \VAR{generic-function}
    \VAR{method} \OPn{\VAR{arg}})}
  {
    Called on invocation of \kwd{call-next-method} when there is no next
    method.  Default method signals \kwd{error}.  Not to be called by
    user.
  }

  \IT{(\GFU*{FUNCTION-KEYWORDS} \VAR{method})}
  {
    Return list of \retval{keyword parameters} of \VAR{method} and
    \retvalii{\T} if other keys are allowed.
  }

  \IT{(\GFU*{METHOD-QUALIFIERS} \VAR{method})}
  {
    \VAR{method} 的 \retval{限定符列表}。
  }


\end{LIST}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{方法组合类型} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{section:方法组合类型}
\begin{LIST}{1cm}

  \IT{\kwd*{STANDARD}}
  {
  Evaluate most specific \kwd{:around} method supplying the values of
  the generic function. From within this method, \FU{call-next-method}
  can call less specific \kwd{:around} methods if there are any. If
  not, or if there are no \kwd{:around} methods at all, call all
  \kwd{:before} methods, most specific first, and the most specific
  primary method which supplies the values of the calling
  \FU{call-next-method} if any, or of the generic function; and which
  can call less specific primary methods via
  \FU{call-next-method}. After its return, call all \kwd{:after}
  methods, least specific first.
  }

  \IT{\kwd*{AND}\XOR
      \kwd*{OR}\XOR
      \kwd*{APPEND}\XOR
      \kwd*{LIST}\XOR      \kwd*{NCONC}\XOR
      \kwd*{PROGN}\XOR
      \kwd*{MAX}\XOR
      \kwd*{MIN}\XOR
      \kwd*{+}}
  {
    Simple built-in \kwd{method-combination} types; have the same
    usage as the
    \VAR{c-type}s defined by the short form of
    \MC{define-method-combination}. 
  }

  \IT{(\MC*{DEFINE-METHOD-COMBINATION} \VAR{c-type}
    \orGOO{%
      \kwd{:documentation } \NEV{\VAR{string}}\\
      \kwd{:identity-with-one-argument} \VAR{ bool}\DF{\NIL}\\
      \kwd{:operator} \VAR{ operator}\DF{\VAR{c-type}}}{\}})}
  {
    \EM{Short Form. } Define new \kwd{method-combination}
    \retval{\VAR{c-type}}. In a generic function using \VAR{c-type},
    evaluate most specific \kwd{:around} method supplying the values of
    the generic function. From within this method, \FU{call-next-method}
    can call less specific \kwd{:around} methods if there are any.  If
    not, or if there are no \kwd{:around} methods at all,
    return from the calling \kwd{call-next-method} or from the
    generic function, respectively, the
    values of (\VAR{operator} \OPn{(\VAR{primary-method}
      \OPn{\VAR{gen-arg}})}), \OPn{\VAR{gen-arg}} being the arguments of the
    generic function.
    The \VAR{primary-method}s are ordered
    \OP{\xorGOO{%
        \kwd{:most-specific-first}\\
        \kwd{:most-specific-last}%
      }{\}}\DF{\kwd{:most-specific-first}}}
    (specified as \VAR{c-arg} in \MC{defgeneric}).
    Using \VAR{c-type} as the \VAR{qualifier} in \MC{defmethod}
    makes the method primary.
  }

  \IT{(\MC*{DEFINE-METHOD-COMBINATION} \VAR{c-type}
    (\OPn{\VAR{ord-$\lambda$}}) 
    (\OPn{(\VAR{group} \xorGOO{%
        \kwd{\A}\\
        (\OPn{\VAR{qualifier}}\text{ } \OP{\kwd{\A}})\\
        \VAR{predicate}}{\}} 
      \orGOO{%
        \kwd{:description} \VAR{ control}\\
        \kwd{:order }
        \xorGOO{\kwd{:most-specific-first}\\
          \kwd{:most-specific-last}}{\}}\DF{\kwd{:most-specific-first}}\\ 
        \kwd{:required} \VAR{ bool}}{\}})})
    \orGOO{%
      (\kwd{:arguments } \OPn{\VAR{method-combination-$\lambda$}})\\
      (\kwd{:generic-function} \VAR{ symbol})\\
      \OPn{(\kwd{declare } \OPn{\NEV{\VAR{decl}}})}\\
      \NEV{\VAR{doc}}}{\}}
    \PROGN{\VAR{body}})}
  {
    \EM{Long Form. } Define new \kwd{method-combination}
    \retval{\VAR{c-type}}. A call to a generic function using
    \VAR{c-type} will be equivalent to a call to the forms returned by
    \OPn{\VAR{body}} with \OPn{\VAR{ord-$\lambda$}} bound to
    \OPn{\VAR{c-arg}} (cf.\ \MC{DEFGENERIC}), with \VAR{symbol} bound to
    the generic function, with \OPn{\VAR{method-combination-$\lambda$}}
    bound to the arguments of the generic function, and with
    \VAR{group}s bound to lists of methods. An applicable method becomes
    a member of the leftmost \VAR{group} whose \VAR{predicate} or
    \VAR{qualifier}s match. Methods can be called via
    \MC{CALL-METHOD}. Lambda lists (\OPn{\VAR{ord-$\lambda$}}) and
    (\OPn{\VAR{method-combination-$\lambda$}}) according to
    \VAR{ord-$\lambda$} on page \pageref{section:函数}, the latter
    enhanced by an optional \kwd{\&whole} argument.
  }

  \IT{(\MC*{CALL-METHOD} \xorGOO{\NEV{\VAR{method}}\\
      (\MC*{MAKE-METHOD}\text{ } \NEV{\VAR{form}})}{\}}%
    \OP{(\xorGOO{%
      \NEV{\VAR{next-method}}\\
      (\MC*{MAKE-METHOD}\text{ } \NEV{\VAR{form}})}{\}^{\!\!*}})})}
  {
    From within an effective method form, call \VAR{method} with the
    arguments of the generic function and
    with information about its \VAR{next-method}s; return \retval{its
      values}. 
  }

\end{LIST}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "clqr"
%%% End: 
